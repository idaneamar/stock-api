#!/usr/bin/env python3
"""
exeopt.py - Execute options recommendations from optsp.py to IBKR

This script reads iron condor recommendations generated by optsp.py and submits
them to Interactive Brokers with stop loss and take profit orders.

The script:
1. Automatically finds today's recommendation file (or most recent from last 7 days)
2. Reads recommendations from CSV/Excel files generated by optsp.py
3. Creates iron condor combo contracts (4-leg options strategy)
4. Places entry orders to open the iron condor positions
5. Sets up stop loss and take profit orders using OCA (One-Cancels-All) groups
   - Stop Loss: Closes position when loss reaches a threshold (default: 100% of max_loss)
   - Take Profit: Closes position when profit reaches a target (default: 50% of max_profit)

Note: Stop loss and take profit orders use limit orders based on the calculated
close prices. In production, you may want to use conditional orders based on
unrealized P&L or use bracket orders for more sophisticated risk management.

Dependencies:
  pip install ib_insync pandas openpyxl

Prerequisites:
  - IBKR TWS (Trader Workstation) or IB Gateway must be running
  - API must be enabled in TWS/Gateway settings
  - Paper trading port: 7497, Live trading port: 7496

Usage:
  # Auto-detect and execute today's recommendations (recommended)
  python3 exeopt.py
  
  # Use specific file
  python3 exeopt.py --file options_recommendations/iron_condor_2024-01-15.csv
  
  # Dry run mode (test without placing orders)
  python3 exeopt.py --dry-run
  
  # Custom SL/TP percentages
  python3 exeopt.py --stop-loss-pct 0.80 --take-profit-pct 0.60
  
  # Custom IBKR connection
  python3 exeopt.py --host localhost --port 7497
"""

from __future__ import annotations

import os
import sys
import argparse
import logging
from datetime import datetime, date, timedelta
from typing import Optional, Dict, List, Tuple
from decimal import Decimal
import glob

import pandas as pd
from ib_insync import IB, Option, Contract, Order, LimitOrder, StopOrder, ComboLeg, ContractDetails
from ib_insync import MarketOrder, StopLimitOrder

# =========================
# Logging
# =========================
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(levelname)s - %(message)s",
    handlers=[logging.StreamHandler()],
)
logger = logging.getLogger(__name__)

# =========================
# Configuration
# =========================
DEFAULT_HOST = "127.0.0.1"
DEFAULT_PORT = 7497  # TWS Paper Trading: 7497, Live: 7496
DEFAULT_CLIENT_ID = 1

# Risk management defaults
DEFAULT_STOP_LOSS_PCT = 1.0  # Close position if loss reaches 100% of max_loss
DEFAULT_TAKE_PROFIT_PCT = 0.50  # Close position if profit reaches 50% of max_profit

# Default directories (matching optsp.py)
SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
BASE_DIR = os.environ.get("STOCK_BASE_DIR") or SCRIPT_DIR
DEFAULT_RECOMMENDATIONS_DIR = os.path.join(BASE_DIR, "options_recommendations")
DEFAULT_OUTPUT_PREFIX = "iron_condor"


class IBKROptionsExecutor:
    """Execute options recommendations to IBKR with SL/TP orders."""

    def __init__(self, host: str = DEFAULT_HOST, port: int = DEFAULT_PORT, client_id: int = DEFAULT_CLIENT_ID):
        self.ib = IB()
        self.host = host
        self.port = port
        self.client_id = client_id
        self.connected = False

    def connect(self) -> bool:
        """Connect to IBKR TWS/Gateway."""
        try:
            self.ib.connect(self.host, self.port, clientId=self.client_id)
            self.connected = True
            logger.info(f"Connected to IBKR at {self.host}:{self.port}")
            return True
        except Exception as e:
            logger.error(f"Failed to connect to IBKR: {e}")
            self.connected = False
            return False

    def disconnect(self):
        """Disconnect from IBKR."""
        if self.connected:
            try:
                self.ib.disconnect()
                self.connected = False
                logger.info("Disconnected from IBKR")
            except Exception as e:
                logger.error(f"Error disconnecting: {e}")

    def get_option_contract(
        self, symbol: str, strike: float, exp_date: str, right: str, exchange: str = "SMART"
    ) -> Optional[Contract]:
        """
        Get option contract for given parameters.
        
        Args:
            symbol: Underlying symbol (e.g., "AAPL")
            strike: Strike price
            exp_date: Expiration date in YYYYMMDD format (or YYYY-MM-DD which will be converted)
            right: "C" for call, "P" for put
            exchange: Exchange (default: "SMART")
        """
        try:
            # Convert expiration date to IBKR format (YYYYMMDD)
            if "-" in exp_date:
                exp_ibkr = exp_date.replace("-", "")
            else:
                exp_ibkr = exp_date

            option = Option(symbol, exp_ibkr, strike, right, exchange)
            qualified = self.ib.qualifyContracts(option)

            if qualified:
                return qualified[0]
            else:
                logger.warning(f"Could not qualify option: {symbol} {exp_ibkr} {strike} {right}")
                return None
        except Exception as e:
            logger.error(f"Error getting option contract for {symbol} {strike} {right}: {e}")
            return None

    def create_iron_condor_contract(
        self,
        symbol: str,
        exp_date: str,
        short_put_strike: float,
        long_put_strike: float,
        short_call_strike: float,
        long_call_strike: float,
    ) -> Optional[Contract]:
        """
        Create an iron condor combo contract (4-leg options strategy).
        
        Iron Condor structure:
        - Sell Put at short_put_strike
        - Buy Put at long_put_strike
        - Sell Call at short_call_strike
        - Buy Call at long_call_strike
        """
        try:
            # Convert expiration date to IBKR format (YYYYMMDD)
            if "-" in exp_date:
                exp_ibkr = exp_date.replace("-", "")
            else:
                exp_ibkr = exp_date

            # Get all 4 option contracts (each fully qualified with a conId)
            short_put = self.get_option_contract(symbol, short_put_strike, exp_ibkr, "P")
            long_put = self.get_option_contract(symbol, long_put_strike, exp_ibkr, "P")
            short_call = self.get_option_contract(symbol, short_call_strike, exp_ibkr, "C")
            long_call = self.get_option_contract(symbol, long_call_strike, exp_ibkr, "C")

            if not all([short_put, long_put, short_call, long_call]):
                logger.error("Could not qualify all option contracts for iron condor")
                return None

            # Log the conIds for debugging
            logger.info(
                f"Leg conIds — short_put={short_put.conId}, long_put={long_put.conId}, "
                f"short_call={short_call.conId}, long_call={long_call.conId}"
            )

            # Determine the exchange from the qualified legs (prefer the first non-empty exchange)
            leg_exchange = next(
                (c.exchange for c in [short_put, long_put, short_call, long_call] if c.exchange),
                "SMART",
            )

            # Create combo (BAG) contract.
            # Do NOT call qualifyContracts on the bag itself — IBKR cannot qualify
            # a combo the same way as individual contracts.  The individual legs are
            # already qualified above, so just build the bag directly.
            combo = Contract()
            combo.symbol = symbol
            combo.secType = "BAG"
            combo.currency = "USD"
            combo.exchange = "SMART"

            # Leg actions are defined from the BUY-to-close perspective:
            #   BUY combo → executes legs as-is   → closes the position
            #   SELL combo → IBKR reverses legs   → opens the position
            #
            # Opening (SELL iron condor):   SELL short_put, BUY long_put, SELL short_call, BUY long_call
            # Closing (BUY to close):       BUY short_put, SELL long_put, BUY short_call, SELL long_call
            #
            # So define legs in the CLOSING direction:
            combo.comboLegs = [
                ComboLeg(conId=short_put.conId,  ratio=1, action="BUY",  exchange=leg_exchange),  # close: buy back short put
                ComboLeg(conId=long_put.conId,   ratio=1, action="SELL", exchange=leg_exchange),  # close: sell back long put
                ComboLeg(conId=short_call.conId, ratio=1, action="BUY",  exchange=leg_exchange),  # close: buy back short call
                ComboLeg(conId=long_call.conId,  ratio=1, action="SELL", exchange=leg_exchange),  # close: sell back long call
            ]

            return combo

        except Exception as e:
            logger.error(f"Error creating iron condor contract: {e}")
            return None

    def calculate_stop_loss_price(self, net_credit: float, max_loss_per_share: float, stop_loss_pct: float) -> float:
        """
        Calculate stop loss price for iron condor.
        
        For iron condor:
        - Entry: net_credit (credit received)
        - Max loss: max_loss_per_share (net debit if both wings are breached)
        - Stop loss: Close position when loss reaches stop_loss_pct of max_loss
        
        Returns the debit price at which to close (negative value means we pay to close)
        """
        max_loss = max_loss_per_share
        stop_loss_amount = max_loss * stop_loss_pct
        # If we received credit, we close at a debit when loss threshold is hit
        # Close price = net_credit - stop_loss_amount (negative = debit)
        close_price = net_credit - stop_loss_amount
        return close_price

    def calculate_take_profit_price(self, net_credit: float, take_profit_pct: float) -> float:
        """
        Calculate take profit price for iron condor.
        
        For iron condor:
        - Entry: net_credit (credit received)
        - Max profit: net_credit (if position expires worthless)
        - Take profit: Close position when profit reaches take_profit_pct of max_profit
        
        Returns the credit price at which to close (positive value means we receive credit)
        """
        max_profit = net_credit
        take_profit_amount = max_profit * take_profit_pct
        # Close price = net_credit - take_profit_amount (we want to keep most of the credit)
        # This means we close at a small debit to lock in profit
        close_price = net_credit - take_profit_amount
        return close_price

    def place_iron_condor_order(
        self,
        symbol: str,
        exp_date: str,
        short_put_strike: float,
        long_put_strike: float,
        short_call_strike: float,
        long_call_strike: float,
        contracts: int,
        net_credit: float,
        max_loss_per_share: float,
        stop_loss_pct: float = DEFAULT_STOP_LOSS_PCT,
        take_profit_pct: float = DEFAULT_TAKE_PROFIT_PCT,
        dry_run: bool = False,
    ) -> Tuple[Optional[Order], Optional[Order], Optional[Order]]:
        """
        Place iron condor order with stop loss and take profit using OCA groups.
        
        For options strategies, we use OCA (One-Cancels-All) groups where:
        - Entry order opens the position
        - Stop loss and take profit orders are in an OCA group
        - When one fills, the other is cancelled
        
        Returns:
            Tuple of (entry_order, stop_loss_order, take_profit_order)
        """
        try:
            # Create iron condor contract
            combo = self.create_iron_condor_contract(
                symbol, exp_date, short_put_strike, long_put_strike, short_call_strike, long_call_strike
            )
            if not combo:
                return None, None, None

            # Get market data to determine entry price
            ticker = self.ib.reqMktData(combo, "", False, False)
            self.ib.sleep(2)  # Wait for market data
            
            # Calculate entry limit price (we want to receive at least net_credit)
            # For iron condor, we're selling, so we want a limit order at net_credit or better
            entry_limit_price = net_credit
            
            # Calculate stop loss and take profit prices
            stop_loss_price = self.calculate_stop_loss_price(net_credit, max_loss_per_share, stop_loss_pct)
            take_profit_price = self.calculate_take_profit_price(net_credit, take_profit_pct)
            
            # Generate OCA group name (unique per position)
            oca_group = f"IC_{symbol}_{exp_date.replace('-', '')}_{int(short_put_strike)}_{int(short_call_strike)}"
            
            # Always log the order details so live runs are auditable
            mode_tag = "[DRY RUN]" if dry_run else "[LIVE]"
            logger.info(
                f"{mode_tag} {symbol} iron condor — "
                f"Strikes: {long_put_strike}/{short_put_strike}P | {short_call_strike}/{long_call_strike}C  "
                f"Exp: {exp_date}  Contracts: {contracts}"
            )
            logger.info(
                f"{mode_tag} Inputs — net_credit: ${net_credit:.4f}  "
                f"max_loss/share: ${max_loss_per_share:.4f}  "
                f"SL%: {stop_loss_pct*100:.0f}%  TP%: {take_profit_pct*100:.0f}%"
            )
            logger.info(
                f"{mode_tag} Entry limit: SELL {contracts} @ ${entry_limit_price:.4f}  |  "
                f"SL close: BUY @ ${abs(stop_loss_price):.4f}  |  "
                f"TP close: BUY @ ${abs(take_profit_price):.4f}"
            )
            logger.info(
                f"{mode_tag} Market data — bid: {ticker.bid}  ask: {ticker.ask}  "
                f"last: {ticker.last}  mid: {ticker.midpoint()}"
            )
            logger.info(f"{mode_tag} OCA Group: {oca_group}")

            if dry_run:
                return None, None, None

            # Create entry order (limit order to open iron condor)
            entry_order = LimitOrder("SELL", contracts, entry_limit_price)
            entry_order.tif = "DAY"  # Day order
            entry_order.transmit = True
            
            # Place entry order
            entry_trade = self.ib.placeOrder(combo, entry_order)
            logger.info(f"[LIVE] Entry order placed — orderId: {entry_trade.order.orderId}  status: {entry_trade.orderStatus.status}")
            
            # Wait for order to fill before placing SL/TP
            # Note: In production, you should wait for actual fill confirmation using trade.filledEvent
            # For now, we wait a short time and assume the order will fill
            # In a production system, you'd want to monitor the trade status properly
            logger.info("Waiting for entry order to fill...")
            self.ib.sleep(3)
            
            # Check if entry order filled (simplified check)
            if entry_trade.orderStatus.status not in ["Filled", "PartiallyFilled"]:
                logger.warning(f"Entry order status: {entry_trade.orderStatus.status}. SL/TP orders will be placed anyway.")
            
            # Create stop loss order (buy to close when loss threshold is hit)
            # Stop loss: Buy back the iron condor at stop_loss_price (debit)
            stop_loss_order = LimitOrder("BUY", contracts, abs(stop_loss_price))
            stop_loss_order.tif = "GTC"  # Good till cancelled
            stop_loss_order.ocaGroup = oca_group
            stop_loss_order.ocaType = 1  # Cancel all remaining orders in OCA group when one fills
            
            # Create take profit order (buy to close when profit target is reached)
            # Take profit: Buy back the iron condor at take_profit_price (small debit to lock profit)
            take_profit_order = LimitOrder("BUY", contracts, abs(take_profit_price))
            take_profit_order.tif = "GTC"
            take_profit_order.ocaGroup = oca_group
            take_profit_order.ocaType = 1  # Cancel all remaining orders in OCA group when one fills
            
            # Place stop loss and take profit orders
            sl_trade = self.ib.placeOrder(combo, stop_loss_order)
            tp_trade = self.ib.placeOrder(combo, take_profit_order)

            logger.info(
                f"[LIVE] SL order placed  — orderId: {sl_trade.order.orderId}  "
                f"BUY {contracts} @ ${abs(stop_loss_price):.4f}  GTC  OCA: {oca_group}"
            )
            logger.info(
                f"[LIVE] TP order placed  — orderId: {tp_trade.order.orderId}  "
                f"BUY {contracts} @ ${abs(take_profit_price):.4f}  GTC  OCA: {oca_group}"
            )
            logger.info(
                f"[LIVE] {symbol} summary — entry ${entry_limit_price:.4f} credit | "
                f"SL closes at ${abs(stop_loss_price):.4f} debit (max loss {stop_loss_pct*100:.0f}%) | "
                f"TP closes at ${abs(take_profit_price):.4f} debit (keeps {take_profit_pct*100:.0f}% of credit)"
            )
            
            return entry_order, stop_loss_order, take_profit_order

        except Exception as e:
            logger.error(f"Error placing iron condor order: {e}")
            import traceback
            logger.error(traceback.format_exc())
            return None, None, None

    def execute_recommendations(
        self,
        df: pd.DataFrame,
        stop_loss_pct: float = DEFAULT_STOP_LOSS_PCT,
        take_profit_pct: float = DEFAULT_TAKE_PROFIT_PCT,
        dry_run: bool = False,
    ) -> List[Dict]:
        """
        Execute all recommendations from DataFrame.
        
        Expected columns in df:
        - ticker
        - exp (expiration date)
        - short_put, long_put, short_call, long_call (strikes)
        - contracts
        - net_credit
        - max_loss_per_share
        """
        results = []
        
        for idx, row in df.iterrows():
            try:
                symbol = str(row["ticker"])
                exp_date = str(row["exp"])
                short_put = float(row["short_put"])
                long_put = float(row["long_put"])
                short_call = float(row["short_call"])
                long_call = float(row["long_call"])
                contracts = int(row.get("contracts", 1))
                net_credit = float(row["net_credit"])
                max_loss_per_share = float(row["max_loss_per_share"])
                
                logger.info(f"\n{'='*60}")
                logger.info(f"Processing recommendation {idx + 1}/{len(df)}")
                logger.info(f"Symbol: {symbol}, Exp: {exp_date}")
                logger.info(f"Iron Condor: SP={short_put}, LP={long_put}, SC={short_call}, LC={long_call}")
                logger.info(f"Contracts: {contracts}, Credit: ${net_credit:.2f}, Max Loss: ${max_loss_per_share:.2f}")
                
                entry_order, sl_order, tp_order = self.place_iron_condor_order(
                    symbol=symbol,
                    exp_date=exp_date,
                    short_put_strike=short_put,
                    long_put_strike=long_put,
                    short_call_strike=short_call,
                    long_call_strike=long_call,
                    contracts=contracts,
                    net_credit=net_credit,
                    max_loss_per_share=max_loss_per_share,
                    stop_loss_pct=stop_loss_pct,
                    take_profit_pct=take_profit_pct,
                    dry_run=dry_run,
                )
                
                result = {
                    "index": idx,
                    "symbol": symbol,
                    "exp_date": exp_date,
                    "entry_order": entry_order.orderId if entry_order and hasattr(entry_order, 'orderId') else None,
                    "stop_loss_order": sl_order.orderId if sl_order and hasattr(sl_order, 'orderId') else None,
                    "take_profit_order": tp_order.orderId if tp_order and hasattr(tp_order, 'orderId') else None,
                    "success": entry_order is not None,
                }
                results.append(result)
                
            except Exception as e:
                logger.error(f"Error processing recommendation {idx + 1}: {e}")
                results.append({
                    "index": idx,
                    "symbol": str(row.get("ticker", "UNKNOWN")),
                    "success": False,
                    "error": str(e),
                })
        
        return results


def find_todays_recommendation_file(recommendations_dir: str = DEFAULT_RECOMMENDATIONS_DIR, prefix: str = DEFAULT_OUTPUT_PREFIX) -> Optional[str]:
    """
    Automatically find today's recommendation file.
    Looks for files matching: {prefix}_YYYY-MM-DD.csv or .xlsx
    
    If today's file doesn't exist, looks for the most recent file from the last 7 days.
    """
    # Check if directory exists
    if not os.path.exists(recommendations_dir):
        logger.warning(f"Recommendations directory does not exist: {recommendations_dir}")
        return None
    
    today = date.today()
    today_str = today.isoformat()
    
    # Try today's date first
    patterns = [
        os.path.join(recommendations_dir, f"{prefix}_{today_str}.csv"),
        os.path.join(recommendations_dir, f"{prefix}_{today_str}.xlsx"),
    ]
    
    for pattern in patterns:
        if os.path.exists(pattern):
            logger.info(f"Found today's recommendation file: {pattern}")
            return pattern
    
    # If today's file doesn't exist, look for the most recent file in the last 7 days
    logger.info(f"Today's file ({today_str}) not found. Searching for recent files...")
    
    for days_back in range(1, 8):  # Check last 7 days
        check_date = today - timedelta(days=days_back)
        check_date_str = check_date.isoformat()
        
        for ext in [".csv", ".xlsx"]:
            file_path = os.path.join(recommendations_dir, f"{prefix}_{check_date_str}{ext}")
            if os.path.exists(file_path):
                logger.info(f"Found recent recommendation file: {file_path} (from {check_date_str})")
                return file_path
    
    # If still not found, try to find any matching file
    logger.warning("No recent files found. Searching for any matching files...")
    csv_pattern = os.path.join(recommendations_dir, f"{prefix}_*.csv")
    xlsx_pattern = os.path.join(recommendations_dir, f"{prefix}_*.xlsx")
    
    all_files = glob.glob(csv_pattern) + glob.glob(xlsx_pattern)
    if all_files:
        # Sort by modification time, get most recent
        most_recent = max(all_files, key=os.path.getmtime)
        logger.info(f"Using most recent file found: {most_recent}")
        return most_recent
    
    return None


def load_recommendations(file_path: str) -> pd.DataFrame:
    """Load recommendations from CSV or Excel file."""
    if not os.path.exists(file_path):
        raise FileNotFoundError(f"File not found: {file_path}")
    
    if file_path.endswith(".csv"):
        df = pd.read_csv(file_path)
    elif file_path.endswith((".xlsx", ".xls")):
        df = pd.read_excel(file_path)
    else:
        raise ValueError(f"Unsupported file format: {file_path}")
    
    # Validate required columns
    required_cols = ["ticker", "exp", "short_put", "long_put", "short_call", "long_call", "net_credit", "max_loss_per_share"]
    missing_cols = [c for c in required_cols if c not in df.columns]
    if missing_cols:
        raise ValueError(f"Missing required columns: {missing_cols}")
    
    return df


def main():
    parser = argparse.ArgumentParser(
        description="Execute options recommendations from optsp.py to IBKR. "
                    "If --file is not provided, automatically finds today's recommendation file.",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Auto-detect today's file and execute
  python3 exeopt.py
  
  # Use specific file
  python3 exeopt.py --file options_recommendations/iron_condor_2024-01-15.csv
  
  # Dry run mode
  python3 exeopt.py --dry-run
        """
    )
    parser.add_argument(
        "--file",
        type=str,
        default=None,
        help="Path to recommendations CSV or Excel file from optsp.py. "
             "If not provided, automatically finds today's file in options_recommendations/",
    )
    parser.add_argument(
        "--recommendations-dir",
        type=str,
        default=DEFAULT_RECOMMENDATIONS_DIR,
        help=f"Directory to search for recommendation files (default: {DEFAULT_RECOMMENDATIONS_DIR})",
    )
    parser.add_argument(
        "--host",
        type=str,
        default=DEFAULT_HOST,
        help=f"IBKR TWS/Gateway host (default: {DEFAULT_HOST})",
    )
    parser.add_argument(
        "--port",
        type=int,
        default=DEFAULT_PORT,
        help=f"IBKR TWS/Gateway port (default: {DEFAULT_PORT}, Paper: 7497, Live: 7496)",
    )
    parser.add_argument(
        "--client-id",
        type=int,
        default=DEFAULT_CLIENT_ID,
        help=f"IBKR client ID (default: {DEFAULT_CLIENT_ID})",
    )
    parser.add_argument(
        "--stop-loss-pct",
        type=float,
        default=DEFAULT_STOP_LOSS_PCT,
        help=f"Stop loss percentage of max loss (default: {DEFAULT_STOP_LOSS_PCT})",
    )
    parser.add_argument(
        "--take-profit-pct",
        type=float,
        default=DEFAULT_TAKE_PROFIT_PCT,
        help=f"Take profit percentage of max profit (default: {DEFAULT_TAKE_PROFIT_PCT})",
    )
    parser.add_argument(
        "--dry-run",
        action="store_true",
        help="Dry run mode - don't actually place orders",
    )
    
    args = parser.parse_args()
    
    try:
        # Auto-detect file if not provided
        if args.file is None:
            logger.info("No file specified. Auto-detecting today's recommendation file...")
            args.file = find_todays_recommendation_file(
                recommendations_dir=args.recommendations_dir,
                prefix=DEFAULT_OUTPUT_PREFIX
            )
            if args.file is None:
                logger.error(f"Could not find any recommendation files in {args.recommendations_dir}")
                logger.error(f"Expected pattern: {DEFAULT_OUTPUT_PREFIX}_YYYY-MM-DD.csv or .xlsx")
                sys.exit(1)
        
        # Load recommendations
        logger.info(f"Loading recommendations from: {args.file}")
        df = load_recommendations(args.file)
        logger.info(f"Loaded {len(df)} recommendations")
        
        # Create executor
        executor = IBKROptionsExecutor(host=args.host, port=args.port, client_id=args.client_id)
        
        # Connect to IBKR
        if not args.dry_run:
            if not executor.connect():
                logger.error("Failed to connect to IBKR. Exiting.")
                sys.exit(1)
        else:
            logger.info("[DRY RUN MODE] Skipping IBKR connection")
        
        try:
            # Execute recommendations
            results = executor.execute_recommendations(
                df,
                stop_loss_pct=args.stop_loss_pct,
                take_profit_pct=args.take_profit_pct,
                dry_run=args.dry_run,
            )
            
            # Summary
            successful = sum(1 for r in results if r.get("success", False))
            failed = len(results) - successful
            logger.info(f"\n{'='*60}")
            logger.info(f"Execution Summary:")
            logger.info(f"Total recommendations: {len(results)}")
            logger.info(f"Successful: {successful}")
            logger.info(f"Failed: {failed}")
            
        finally:
            if not args.dry_run:
                executor.disconnect()

        if successful == 0 and len(results) > 0:
            logger.error(f"All {len(results)} order(s) failed. Exiting with error.")
            sys.exit(1)
    
    except Exception as e:
        logger.error(f"Error: {e}", exc_info=True)
        sys.exit(1)


if __name__ == "__main__":
    main()
